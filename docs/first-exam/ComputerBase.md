# 计算机基础

计算机基础在校招中考核较为常见，尤其是大厂，不可忽视。

## 进程和线程的区别

::: details 参考答案

| 特性       | 进程 (Process)                 | 线程 (Thread)                    |
| :--------- | :----------------------------- | :------------------------------- |
| **定义**   | 操作系统资源分配的最小单位     | CPU 调度的最小单位               |
| **资源**   | 拥有独立的内存空间、文件描述符 | 共享进程的内存和资源，独享栈空间 |
| **开销**   | 创建/销毁/切换开销大           | 开销小，切换快                   |
| **通信**   | 进程间通信 (IPC) 复杂          | 线程间直接读写共享数据，简单     |
| **健壮性** | 进程崩溃不影响其他进程         | 一个线程崩溃可能导致整个进程崩溃 |

**通俗理解**:

- **进程**就像一个**工厂**，有独立的资源（厂房、电力）。
- **线程**就像工厂里的**工人**，共享工厂的资源，协同工作。

**举例**:

- **Chrome 浏览器**: 每个 Tab 页是一个进程（沙箱隔离，一个崩了不影响其他）。
- **WebWorker**: 是 JS 中的多线程方案，不阻塞主线程 UI 渲染。
- **Node.js**: 单线程模型（主线程），但利用多进程（Cluster）利用多核 CPU。

:::

## 进程间的通信方式 (IPC)

::: details 参考答案

进程间通信（IPC, Inter-Process Communication）主要有以下几种方式，**效率由低到高**排序：

1.  **管道 (Pipe)**:
    - **匿名管道**: 仅用于父子进程间通信。
    - **命名管道 (FIFO)**: 可用于无亲缘关系进程。
    - _特点_: 半双工（数据单向流动），像水管一样。
2.  **消息队列 (Message Queue)**:
    - 消息的链表，存放在内核中。
    - _特点_: 解决了管道数据无格式、缓冲区受限的问题。
3.  **信号量 (Semaphore)**:
    - 本质是一个计数器，用于**进程同步**和互斥，而不是传输数据。
    - _特点_: 控制多个进程对共享资源的访问。
4.  **共享内存 (Shared Memory)**:
    - **最快**的 IPC 方式。多个进程映射同一块物理内存。
    - _特点_: 不需要数据拷贝，但需要配合信号量解决同步问题。
5.  **套接字 (Socket)**:
    - 用于**不同主机**（或同主机）间的进程通信。
    - _特点_: 支持 TCP/UDP，适用范围最广（网络通信）。

:::

## 请简述编译器的执行过程？前端常见的编译工具？

::: details 参考答案

**1. 编译器的执行过程**

1.  **词法分析**: 将代码切割成 Token (标记)，如 `var`, `a`, `=`, `1`。
2.  **语法分析**: 将 Token 转化为 **AST (抽象语法树)**。这是很多前端工具 (Babel, Eslint) 的基础。
3.  **语义分析**: 检查类型、作用域等。
4.  **中间代码生成**: 生成平台无关的中间代码。
5.  **代码优化**: 删除无用代码、循环优化等。
6.  **目标代码生成**: 生成机器码。

**2. 前端常见的编译工具**

- **Babel**: 将 ES6+ 代码转换为 ES5 (核心是操作 AST)。
- **TypeScript Compiler (tsc)**: 将 TS 转换为 JS。
- **PostCSS / Sass**: 将 CSS 预处理语言转换为标准 CSS。
- **Webpack / Vite**: 主要是打包工具，但内置/调用了编译功能。

:::

## 编译型语言和解释型语言的区别？

::: details 参考答案

| 特性         | 编译型语言 (C/C++, Go, Rust)         | 解释型语言 (JS, Python, PHP) |
| :----------- | :----------------------------------- | :--------------------------- |
| **执行方式** | 源码一次性**编译**成机器码，直接运行 | 源码由解释器**逐行**解释执行 |
| **速度**     | 快 (直接执行机器码)                  | 慢 (运行时需要翻译)          |
| **跨平台**   | 差 (需针对不同系统重新编译)          | 好 (有解释器就能跑)          |
| **错误检查** | **编译时**发现语法/类型错误          | **运行时**才报错             |
| **调试**     | 较繁琐                               | 方便，所见即所得             |

> **比喻**:
>
> - **编译型**: 把英文书翻译成中文书，直接读中文书。(一次翻译，多次阅读)
> - **解释型**: 请个同声传译，你读一句英文，他翻译一句。(每次读都要翻译)

**JIT (Just-In-Time) 即时编译**:
现代 JS 引擎 (如 V8) 引入了 JIT。它结合了二者优点：

1.  刚开始用**解释器**执行 (启动快)。
2.  发现**热点代码** (执行频次高的)，将其**编译**成机器码并缓存 (执行快)。
3.  如果代码逻辑变化，再**去优化** (Deoptimization) 回解释执行。

:::

## 简述 JS 垃圾回收 (GC) 的过程？

::: details 参考答案

GC (Garbage Collection) 是为了防止内存泄漏，释放不再使用的对象。

**1. 标记-清除 (Mark-and-Sweep) - 核心算法**

1.  **标记**: 从**根 (Roots)** 开始遍历，能访问到的对象打上"活动"标记。
2.  **清除**: 遍历堆内存，回收没有标记的对象。

可以用一句话理解：从 `window/global` 出发“能摸到的”都活着，摸不到的就是垃圾。

一个更具体的例子：

1.  根对象（例如 `window`）里还引用着 `a`、`b`，那 `a`、`b` 是可达对象。
2.  `a` 里又引用了 `c`，那 `c` 也是可达对象。
3.  有些对象既不在根对象里，也不被任何可达对象引用（形成“孤岛”），它们就会在清除阶段被回收。

**2. 引用计数 (Reference Counting) - 已被淘汰**

- 原理：对象被引用一次，计数+1；引用失效，计数-1。为 0 时回收。
- **致命缺点**: 无法解决**循环引用** (A 引用 B, B 引用 A，计数永远不为 0)。

**3. V8 引擎的分代回收 (Generational GC)**

V8 将堆内存分为**新生代 (New Space)** 和 **老生代 (Old Space)**。

| 区域       | 存放对象                | 回收算法                   | 特点                                                                         |
| :--------- | :---------------------- | :------------------------- | :--------------------------------------------------------------------------- |
| **新生代** | 存活时间短 (临时变量)   | **Scavenge (Cheney 算法)** | 将空间一分为二 (From/To)，复制存活对象到 To，清空 From。速度快，空间换时间。 |
| **老生代** | 存活时间长 (闭包、全局) | **标记-清除 + 标记-整理**  | 标记清除后，整理内存碎片。                                                   |

> **晋升**: 新生代对象如果经过多次回收还在，或者 To 空间快满了，就会被移动到老生代。

:::

## 什么是内存泄漏？如何排查？

::: details 参考答案

**定义**: 程序中已分配的内存，由于某种原因未释放或无法释放，导致系统内存浪费。

**常见原因**:

1.  **意外的全局变量**: 忘记 `var/let/const`，变量挂在 `window` 上。
2.  **被遗忘的定时器**: `setInterval` 未 `clearInterval`。
3.  **闭包**: 长期持有外部变量的引用。
4.  **脱离 DOM 的引用**: 删除了 DOM 节点，但 JS 变量还引用着它。

**如何排查**:

1.  **Chrome DevTools - Memory 面板**:
    - **Heap Snapshot**: 拍摄堆快照，对比操作前后的内存变化。
    - **Allocation instrumentation on timeline**: 实时录制内存分配。
2.  **Performance 面板**: 勾选 Memory，查看内存走势图 (如果是锯齿状上升且不下降，很可能有泄漏)。

:::

## 简述 JS 运行时的堆栈内存模型？

::: details 参考答案

JS 内存分为 **栈 (Stack)** 和 **堆 (Heap)**。

| 区域           | 存储内容                                          | 特点                            | 访问速度                  |
| :------------- | :------------------------------------------------ | :------------------------------ | :------------------------ |
| **栈 (Stack)** | 基本类型 (Number, Boolean...), 引用类型的**地址** | 空间小，线性结构，自动分配/释放 | **快** (LIFO 后进先出)    |
| **堆 (Heap)**  | 引用类型 (Object, Array, Function)                | 空间大，无序结构，需 GC 回收    | **慢** (通过引用地址访问) |

**代码示例**:

```js
let a = 1 // 栈
let obj = { name: 'Heap' } // obj 的地址在栈，内容在堆

function foo() {
  let b = 2 // 栈
  // ...
}
foo() // foo 执行上下文压入栈
```

![JS Call Stack](../imgs/call-stack.png)

> **注意**: 闭包变量存储在**堆**中，因为它需要跨作用域访问，不能随栈帧销毁。

:::

## 为什么 0.1 + 0.2 !== 0.3？如何解决？

::: details 参考答案

**原因 (IEEE 754 精度丢失)**:

1.  **二进制转换**: 计算机用二进制存储小数。0.1 和 0.2 转为二进制是**无限循环**的。
    - `0.1` -> `0.0001100110011...`
    - `0.2` -> `0.0011001100110...`
2.  **截断**: 由于 JS 的 Number 是双精度浮点数 (64位)，只能存储 52 位尾数，多余的被**截断**了。
3.  **计算**: 截断后的二进制相加，再转回十进制，结果是 `0.30000000000000004`。

**解决方案**:

1.  **使用 `toFixed` (不推荐用于计算)**:
    ```js
    parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 // true
    ```
2.  **转为整数计算 (推荐)**:
    ```js
    ;(0.1 * 10 + 0.2 * 10) / 10 === 0.3 // true
    ```
3.  **使用第三方库 (生产环境)**:
    - `decimal.js`
    - `bignumber.js`

:::

## 栈 (Stack) 和队列 (Queue) 的区别？前端哪里用到了？

::: details 参考答案

| 特性     | 栈 (Stack)              | 队列 (Queue)          |
| :------- | :---------------------- | :-------------------- |
| **规则** | **LIFO** (后进先出)     | **FIFO** (先进先出)   |
| **操作** | `push` / `pop`          | `push` / `shift`      |
| **比喻** | 叠盘子 (最后放的最先拿) | 排队买票 (先来的先买) |

**前端应用场景**:

1.  **栈 (Stack)**:

    - **函数调用栈**: JS 执行上下文的管理。
    - **历史记录**: 浏览器的后退功能 (`history.back()`)。
    - **算法**: 括号匹配检查 `(())`。

2.  **队列 (Queue)**:
    - **事件循环 (Event Loop)**:
      - **宏任务队列** (Macro Task Queue): `setTimeout`, `setInterval`。
      - **微任务队列** (Micro Task Queue): `Promise.then`。
    - **消息队列**: 各种异步回调的执行顺序。

:::

## 什么是哈希表 (Hash Map)？如何解决冲突？

::: details 参考答案

**定义**:
哈希表是一种通过 **Key** 直接访问 **Value** 的数据结构。它通过 **哈希函数 (Hash Function)** 将 Key 映射到数组的索引。

**特点**:

- **查询/插入速度快**: 平均时间复杂度 **O(1)**。

**哈希冲突 (Hash Collision)**:
当两个不同的 Key 计算出相同的索引时，就发生了冲突。

**解决方法**:

1.  **链地址法 (Chain Address Method) - JS Map/Object 常用**:
    - 数组的每个位置存储一个**链表**。
    - 冲突时，将新元素追加到链表后面。
2.  **开放寻址法**:
    - 冲突时，向后找下一个空闲位置。

**前端应用**:

- `Object` 和 `Map` (底层通常是 Hash Table + 其它结构优化)。
- Vue/React 的虚拟 DOM Diff 算法中，使用 Map 快速查找 Key。

:::

## 常见的位运算有哪些？前端有什么应用？

::: details 参考答案

**常见运算符**:

- `&` (与): 都为 1 才为 1。
- `|` (或): 有一个 1 就为 1。
- `^` (异或): 不同为 1，相同为 0。
- `<<` (左移): 乘以 2。
- `>>` (右移): 除以 2。

**前端应用场景**:

1.  **权限控制 (最经典)**:
    使用二进制位表示不同的权限。

    ```js
    const READ = 1 // 001
    const WRITE = 2 // 010
    const DELETE = 4 // 100

    let userAuth = READ | WRITE // 011 (拥有的权限)

    // 检查权限
    ;(userAuth & READ) > 0 // true
    ;(userAuth & DELETE) > 0 // false
    ```

2.  **React 源码 (Lane 模型)**:
    React 使用位运算来管理任务的优先级 (Priority)，因为位运算速度极快且占用内存少。

3.  **状态切换**: `toggle = toggle ^ 1` (0 变 1，1 变 0)。

:::

## 什么是 Unicode？和 UTF-8 有什么关系？

::: details 参考答案

**1. Unicode (字符集)**

- **作用**: 为世界上所有的字符分配一个唯一的数字 ID (码点，Code Point)。
- **问题**: 它只规定了字符对应的数字 (如 'A' 是 65, '中' 是 20013)，没规定**计算机怎么存** (是用 2 个字节存？还是 4 个字节？)。

**2. UTF-8 (编码规则)**

- **作用**: 是 Unicode 的一种**实现方式** (存储规则)。
- **特点**: **可变长编码**。
  - 英文: 1 个字节 (兼容 ASCII)。
  - 中文: 通常 3 个字节。
  - Emoji: 4 个字节。

**关系比喻**:

- **Unicode** 是"字典"，规定了每个字的含义和序号。
- **UTF-8** 是"排版规则"，规定了这些字在书本上怎么印刷才最省纸。

> **GBK**: 中国制定的编码标准，主要存汉字 (2字节)，不兼容 Unicode。

:::

## 简述计算机网络的 OSI 模型

::: details 参考答案

OSI 七层模型是网络互联的标准框架。

| 层级  | 名称                     | 作用                    | 常见协议/设备        |
| :---- | :----------------------- | :---------------------- | :------------------- |
| **7** | **应用层** (Application) | 为用户提供网络服务      | HTTP, DNS, SMTP, FTP |
| **6** | 表示层 (Presentation)    | 数据格式转换、加密/解密 | SSL/TLS, JPEG, ASCII |
| **5** | 会话层 (Session)         | 建立、管理会话          | RPC, SQL             |
| **4** | **传输层** (Transport)   | 端到端的可靠/不可靠传输 | **TCP, UDP**         |
| **3** | **网络层** (Network)     | 寻址和路由选择          | **IP**, ICMP, 路由器 |
| **2** | 数据链路层 (Data Link)   | 帧传输、错误检测        | ARP, MAC, 交换机     |
| **1** | 物理层 (Physical)        | 比特流传输 (0/1 信号)   | 网线, 光纤, 网卡     |

> **面试重点**: 前端主要关注 **应用层 (HTTP)** 和 **传输层 (TCP/UDP)**。

![OSI 模型](../imgs/OSI.png)

:::

## 一个域名对应一个 IP 吗？

::: details 参考答案

**不一定。**

1.  **一对一**: 最常见的情况。
2.  **多对一 (多个域名 -> 一个 IP)**:
    - **虚拟主机**: 一台服务器 (IP) 上托管了多个网站 (www.a.com, www.b.com)。Nginx 根据 `Host` 头区分。
3.  **一对多 (一个域名 -> 多个 IP)**:
    - **DNS 轮询 / 负载均衡**: 一个域名解析到多个服务器 IP，分摊流量。
    - **CDN**: 根据用户地理位置，解析到最近的节点 IP。

:::

## TCP 和 UDP 的区别？应用场景？

::: details 参考答案

| 特性         | TCP (Transmission Control Protocol)   | UDP (User Datagram Protocol) |
| :----------- | :------------------------------------ | :--------------------------- |
| **连接**     | **面向连接** (三次握手，四次挥手)     | **无连接** (发就完了)        |
| **可靠性**   | **可靠** (重传机制，不丢包，顺序到达) | **不可靠** (可能丢包，乱序)  |
| **速度**     | 慢 (开销大)                           | **快** (头部小，无拥塞控制)  |
| **流量控制** | 有 (滑动窗口，拥塞控制)               | 无                           |
| **数据格式** | 字节流                                | 数据报文                     |

**应用场景**:

- **TCP**: 对可靠性要求高的场景。
  - 网页浏览 (HTTP/HTTPS)
  - 邮件 (SMTP/POP3)
  - 文件传输 (FTP)
- **UDP**: 对速度要求高，能容忍少量丢包的场景。
  - **视频/语音通话** (Zoom, 微信语音)
  - **直播**
  - **在线游戏** (王者荣耀，FPS 游戏)
  - DNS 查询 (快速)
  - HTTP/3 (QUIC 基于 UDP)

:::

## 数组和链表有什么区别？

::: details 参考答案

| 特性           | 数组 (Array)                            | 链表 (Linked List)                      |
| :------------- | :-------------------------------------- | :-------------------------------------- |
| **内存结构**   | **连续**内存空间                        | **离散**内存空间 (通过指针连接)         |
| **访问效率**   | **O(1)** (随机访问，通过下标计算偏移量) | **O(n)** (需要从头遍历)                 |
| **插入/删除**  | **O(n)** (需要移动后续元素)             | **O(1)** (修改指针即可，前提是已知位置) |
| **空间大小**   | 固定 (需预分配，可能扩容)               | 动态 (按需分配)                         |
| **缓存亲和性** | 好 (连续内存，CPU Cache 命中率高)       | 差 (内存分散)                           |

:::
